from django.shortcuts import render, redirect
from django.views.decorators.http import require_POST, require_GET
from django.views.decorators.csrf import csrf_protect, csrf_exempt
from django.core.paginator import Paginator
from django.http import JsonResponse
import json
import pandas as pd
from .models import notes, get_combined_recommendations, convert_df_to_list, df, model_bert, autoencoder, scaler, features
from django.urls import reverse
import traceback
import numpy as np

# Views
def index(request):
    return render(request, "myapp/index.html")

def feature1(request):
    notes_df = notes.copy()
    notes_df["Notes"] = notes_df["Notes"].str.replace("_", " ").str.title()
    notes_name_list = notes_df["Notes"].tolist()
    context = {"df_notes": notes_df.to_dict(orient='records')}

    is_ajax = request.headers.get('X-Requested-With') == 'XMLHttpRequest'

    if request.method == 'POST':
        try:
            description = ''
            percentages_dict = {}

            if is_ajax:
                data = json.loads(request.body)
                description = data.get('description', '')
                percentages_input = data.get('percentages', {})
                if not isinstance(percentages_input, dict):
                    return JsonResponse({'status': 'error', 'message': 'Invalid percentages format (expected dictionary).'}, status=400)
                for note, perc in percentages_input.items():
                    if isinstance(perc, (int, float)):
                        percentages_dict[note] = perc
                    else:
                        percentages_dict[note] = 0

            else:
                description = request.POST.get('description', '')
                for i, note_name in enumerate(notes_name_list):
                    percentage_key = f'percentage_{i+1}'
                    percentage_str = request.POST.get(percentage_key)
                    try:
                        percentage_val = int(percentage_str) if percentage_str else 0
                        percentages_dict[note_name] = percentage_val
                    except (ValueError, TypeError):
                        print(f"Warning: Invalid percentage value for {percentage_key} ({note_name}): {percentage_str}")
                        percentages_dict[note_name] = 0

            ordered_percentages = []
            if features:
                num_expected_features = len(features)
                print(f"Expected number of features from models.py: {num_expected_features}")
                print(f"Features order from models.py: {features}")
                for feature_name in features:
                    normalized_feature_name = feature_name.replace("_", " ").title()
                    percentage_value = percentages_dict.get(normalized_feature_name, 0)
                    ordered_percentages.append(percentage_value)

                print(f"Number of percentages after ordering: {len(ordered_percentages)}")
                if len(ordered_percentages) != num_expected_features:
                    print(f"Warning: Mismatch between ordered percentages ({len(ordered_percentages)}) and expected features ({num_expected_features}). Padding/truncating may occur in model function.")
            else:
                print("Error: 'features' list from models.py is empty. Cannot determine correct percentage order.")
                if is_ajax:
                    return JsonResponse({'status': 'error', 'message': 'Model features not loaded correctly.'}, status=500)
                else:
                    context['error_message'] = 'Model features not loaded correctly.'
                    return render(request, "myapp/feature1.html", context)

            print("--- Request Data ---")
            print(f"Description: {description}")
            print(f"Input Percentages Dict: {percentages_dict}")
            print(f"Ordered Percentages List (to model): {ordered_percentages}")
            print(f"Is AJAX: {is_ajax}")
            print("--------------------")

            recommendations_df = get_combined_recommendations(description, ordered_percentages)

            if recommendations_df.empty:
                print("No recommendations generated by the model.")
                if is_ajax:
                    return JsonResponse({'recommendations': []})
                else:
                    context['recommendations'] = []
            else:
                recommendations = recommendations_df.to_dict(orient='records')
                print(f"Generated {len(recommendations)} recommendations.")
                
                if is_ajax:
                    return JsonResponse({'recommendations': recommendations})
                else:
                    context['description'] = description
                    context['input_percentages'] = percentages_dict
                    context['recommendations'] = recommendations if not recommendations_df.empty else []
            
            return render(request, "myapp/feature1.html", context)

        except json.JSONDecodeError:
            print("Error decoding JSON from AJAX request.")
            return JsonResponse({'status': 'error', 'message': 'Invalid JSON data.'}, status=400)
        except Exception as e:
            print(f"Error processing request: {e}")
            traceback.print_exc()
            if is_ajax:
                return JsonResponse({'status': 'error', 'message': 'An internal server error occurred.'}, status=500)
            else:
                context['error_message'] = 'An error occurred while generating recommendations.'
                return render(request, "myapp/feature1.html", context)

    else:
        return render(request, "myapp/feature1.html", context)

@csrf_protect
@require_POST
def process_url(request):
    try:
        data = json.loads(request.body)
        url = data.get('url')
        if url is None:
             return JsonResponse({'status': 'error', 'message': 'URL key is missing.'}, status=400)

        input_df, numeric_df = insight(url)

        if input_df.empty:
            return JsonResponse({'status': 'error', 'message': 'URL not found.'}, status=404)

        request.session['numeric_df'] = numeric_df.to_dict(orient='records')
        request.session['input_df'] = input_df.to_dict(orient='records')
        return JsonResponse({'status': 'success', 'message': 'URL diterima.'})

    except json.JSONDecodeError:
        return JsonResponse({'status': 'error', 'message': 'Invalid JSON.'}, status=400)
    except KeyError:
        return JsonResponse({'status': 'error', 'message': 'URL key is missing.'}, status=400)
    except Exception as e:
        return JsonResponse({'status': 'error', 'message': str(e)}, status=500)


def insight(url):
    input_df = df[df['URL'] == url]
    if input_df.empty:
        return pd.DataFrame(), pd.DataFrame()

    numeric_cols = input_df.select_dtypes(include=['number']).columns
    non_zero_mask = (input_df[numeric_cols] != 0) & (input_df[numeric_cols].notna())
    filtered_numeric = input_df[numeric_cols].loc[:, non_zero_mask.any(axis=0)]
    result_df = pd.concat([input_df.drop(columns=numeric_cols), filtered_numeric], axis=1)
    result_df = result_df.drop(columns=['Unnamed:_0', 'Rating_Value', 'Best_Rating', 'Votes'], errors='ignore')
    numeric_df = result_df.select_dtypes(include=['number'])
    return input_df, numeric_df
    
def feature2(request):
    if request.method == 'POST':
        return redirect('feature2')

    df_list = convert_df_to_list(df)
    page_number = request.GET.get('page', 1)
    paginator = Paginator(df_list, 100)
    page_obj = paginator.get_page(page_number)

    # Calculate elided page range in the view
    elided_page_range = paginator.get_elided_page_range(number=page_obj.number, 
                                                         on_each_side=2, 
                                                         on_ends=2)

    # Retrieve numeric_df data from the session (if it exists)
    numeric_df_data = request.session.get('numeric_df')
    input_df_data = request.session.get('input_df')
    numeric_df = None
    input_df = None

    if numeric_df_data:
        numeric_df = pd.DataFrame(numeric_df_data)
        # Modify the column names *before* passing to the template
        new_cols = []
        for col in numeric_df.columns:
             new_cols.append(col.replace("_", " ").title())
        numeric_df.columns = new_cols
    if input_df_data:
        input_df = pd.DataFrame(input_df_data)

    # Add elided_page_range to the context
    context = {
        "datas": page_obj.object_list,
        "page_obj": page_obj,
        "numeric_df": numeric_df,
        "input_df": input_df,
        "elided_page_range": elided_page_range,
    }
    return render(request, "myapp/feature2.html", context)